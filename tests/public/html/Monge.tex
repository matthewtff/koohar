\documentclass[a4paper,10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{amsfonts,longtable,amssymb,amsmath,amsthm}
\usepackage[pdftex]{graphicx}
\graphicspath{{./}}
\usepackage{algorithmic}

\makeatletter 
\renewcommand\appendix{\par 
\setcounter{section}{0}% 
\setcounter{subsection}{0}% 
\gdef\thesection{ \@Asbuk\c@section}} 
\makeatother

\newcommand\myappendix[1]{
\refstepcounter{section}
\section*{Приложение~\thesection{}~#1}
\addcontentsline{toc}{section}{Приложение~\thesection{}~#1}}

%opening
\title{Решение и моделирование транспортной задачи}
\author{Ларионов М. В., Шмаков А. И.}

\begin{document}

\maketitle

\newpage

\begin{abstract}
 В этом документе содержатся постановка задачи курсовой работы
и пояснение ее решения. Здесь приведены основные идеи,
структура и этапы работы программы. Так же излагаются
принципы работы алгоритмов. Однако не приводится никаких подробностей об
особенностях реализации программы и решений каких-то мелких проблем,
так как мы старались не привязываться к какому-либо языку программирования
или средствам разработки. Так же стоит учесть, что материал излагался
учитывая то, что читатель осведомлен с теорией графов и
классическими алгоритмами для работы с ними.
\end{abstract}

\newpage

\section{Условие задачи}
 В условно безграничном трехмерном пространстве существуют два вида объектов:
динамические (поставщики) и статические (потребители и препятствия). При этом
один поставщик может удовлетворить только одного потребителя. Задача считается
решенной лишь тогда, когда удовлетворены все потребители, либо использованы все
поставщики. Решение должно занимать минимальное количество времени (за единицу времени
считать время, необходимое для одного шага\footnote{Шаг~--- перемещение на
еденицу пространства вдоль одной из осей координат}) затраченное на перемещение
всех востребованых поставщиков в пункты назначения.

Решение задачи подразумевает собой две
независимые части: визуализация (для отображения результата)
и поиск математического решения. Визуальная часть рассматриваться не будет,
т.\,к. она не представляет собой научной ценности и требуется исключительно
для демонстрации. %%%%%% подумать над "математического"

Для простоты и наглядности будем представлять обьекты в виде различных фигур
разбитых на частицы (каждая частица имеет форму куба со стороной равной
одной еденице пространства) и может состоять из любого их количества, включая ноль.
Также частица фигуры, представляющей динамический обьект, не может находится
в одной точке пространства с любой другой частицей своей фигуры, либо
фигуры принадлежащей препятствию.

\newpage

\section{Поиск решения}
 Когда впервые слышишь о подобной задаче, кажется, что она легко
разрешима, ведь что сложного в том, что бы каждая частица фигуры
сделала несколько ``шагов'' и оказалась на новом месте? Но в этом
и кроется первая проблема~--- где это место? Хорошо, если
обе фигуры являются одинаковыми и просто находятся на некотором
расстоянии друг от друга, но что делать, если они совершенно
не похожи ни по форме, ни по количеству частиц? И так,
назовем необходимость определения для каждой частицы ``своего места''
{\bfseries проблемой распределения}.
 Формализуем задачу следующим
образом: пусть есть двудольный граф (биграф), вершинами каждой из долей
которого являются частицы первой (все поставщики) и второй (все потребители) фигуры соответственно;
весами ребер будем считать длину кратчайшего пути, который следует
преодолеть, что бы попасть из одной точки пространства в другую (как
определить длину этого пути будет обьяснено позже). В данном полном
двудольном графе требуется выбрать такое максимальное паросочетание\footnote{
Максимальное паросочетание~--- это максимально возможное количество ребер, не
инцидентных одной вершине.},
в котором наибольший вес среди включенных ребер будет минимальным (это нужно
для того, что бы задача решалась за минимальное количествово времени).
Эта задача очень похожа на {\bfseries задачу о назначениях}, однако имеются
сущетвенные различия. Допустим у нас есть биграф с шестью вершинами в каждой доле и
два его паросочетания, в первое из которых входят ребра с весами
$P_1 = \{100, 1, 1, 1, 1, 1\}$, а во второе $P_2 = \{50, 50, 50, 50, 50, 50\}$.
Очевидно, что для задачи о назначениях правильным будет выбор $P_1$, так как
его вес меньше веса $P_2$, однако для нашей задачи это будет означать,
что решение будет получено за $\sim100$ единиц времени, а в случае $P_2$ всего за $\sim50$.
Опираясь на пример можно сделать вывод, что существующий алгоритм для решения задачи
о назначениях (Венгерский алгоритм) нам не подходит. В связи с этим нами был разработан свой
{\bfseries алгоритмом распределения}. Подробней о нем вы можете узнать в приложении\ref{apA}.

Предположим, мы определились со связью текущего и конечного
расположения частиц и осталось осуществить их перемещение.
Другими словами необходимо найти для них путь~--- назовем это
{\bfseries проблемой поиска пути}.
 Это довольно распростроненная задача, а значит и готовых решений довольно
много, но так как мы занимаемся моделированием в реальном времени, то следовало бы выбрать
такой алгоритм, время работы которого было бы минимальным, принебрегая при
этом обьемом выделяемой им памяти. Таким образом алгоритм~$A^*$ стал
решением второй проблемы. Реализован он при помощи списков, что бы
виртуальное пространство, в которм проходит моделирование, было ограничено
только лишь ресурсами вычислительной системы. Описание данного алгоритма
представлено в приложении\ref{apB}. Также при помощи $A^*$ находятся веса
ребер графа, для которого решается первая задача.

\newpage

\appendix

\myappendix{}
\label{apA}

 В этом приложении мы постараемся обьяснить работу алгоритма распределения.
Допустим у нас есть полный двудольный граф с $M$ вершинами в одной доле и
$N$ вершинами в другой. Представим его в виде матрицы~$A$, у которой $M$ столбцов
и $N$ строк (для удобства будем считать что $M \leq N$, в противном случае
нам следует решать задачу для транспонированной матрицы $A^T$). Тогда элемент
матрицы $A_{i,j}$ будет равен весу ребра между $i$-м элементом одной доли
и $j$-м элементом второй, а задача сводится к поиску $M$ элементов стоящих
в разных столбцах и строках.\footnote{Задача легко решается при помощи хвостовой
рекурсии и полного перебора всех возможных комбинаций элементов удовлетворяющих
решению, но сложность такого алгоритма $O(N!)$, что не приемлемо, потому и был
разработан иной алгоритм, в основу которого легли идеи {\bfseries динамического
программирования}.}
Создадим набор $B$ из $M$ матриц (каждая такая матрица состоит из элементов имеющих
три поля: {\bfseries value}~--- собственное числовое значение, {\bfseries
lines}~--- множество, состоящее из номеров использованных строк
и {\bfseries max}~--- максимум из значений уже использованных элементов)
размером $M - 1$ в ширину и $N$ в высоту. $B_i$, где $0 \leq i \leq M - 1$,
будет содержать матрицу хранящую решение задачи для $i$-го столбца исходной
матрицы. $0$-й элемент набора $B$ весь заполняется первым столбцом матрицы $A$,
при этом в поле {\bfseries lines} добавляется номер текущей строки и поле
{\bfseries max} текущим значением, а оставшаяся часть заполняется по следующему правилу:
$$
\begin{aligned}
  B_{i_{k,l}}.value = A_{k,i} + \min_{j=0}^{N-1}(B_{i-1_{j,l}}).value,\\
  B_{i_{k,l}}.lines = \min_{j=0}^{N-1}(B_{i-1_{j,l}}).lines \cup k,\\
  B_{i_{k,l}}.max = \max(A_{k,i}, \min_{j=0}^{N-1}(B_{i-1_{j,l}}).value),
\end{aligned}
$$
где
$$
\begin{aligned}
  1 \leq i \leq M-1,\\
  0 \leq l \leq M-2,\\
  0 \leq k \leq N-1,\\
  k \notin \min_{j=0}^{N-1}(B_{i-1_{j,l}}).lines
\end{aligned}
$$

Таким образом в матрице $B_{M - 1}$ элемент с наименьшим максимумом в поле
{\bfseries lines} будет хранить по порядку номера строк, в которых находятся
нужные элементы. Очевидно, что время выполнения такого алгоритма равно
$O(M^2N)$ или $O(N^3)$ в случае если $M=N$.

\newpage

\myappendix{}
\label{apB}

  Наилучшим алгоритмом для поиска оптимальных путей в различных пространствах
является $A^*$ (читается как ``А-звездочка''). Такой эвристический поиск сортирует
все узлы по приближению наилучшего маршрута, идущего через данный узел. Типичная
формула эвристики выражается в виде:
$$
f(n) = g(n) + h(n),
$$
где $f(n)$~--- значение оценки, назначенное узлу $n$, $g(n)$~--- наименьшая стоимость
прибытия в узел $n$ из точки старта, а $h(n)$~--- эвристическое приближение
стоимости пути к цели от узла $n$. $A^*$ гарантированно находит
кратчайший путь, до тех пор пока эвристическое приближение $h(n)$
является допустимым, то есть он никогда не превышает действительного
оставшегося расстояния до цели.\\
\textsc{А\_звездочка}
\begin{algorithmic}[1]
\STATE {приоритетная очередь $Open$}
\STATE {список $Closed$}
\STATE {$s.g$ = 0}
\STATE {$s.h$ = \textsc{Эвристическая\_Оценка}($s$)}
\STATE {$s.f = s.g + s.h$}
\STATE {$s$.родитель = null}
\STATE {добавить $s$ в Open}
\WHILE {$Open$ не пуста}
  \STATE {извлечь $n$ из $Open$} \COMMENT {$n$~--- узел с нименьшей стоимостью в $Open$}
  \IF {$n$ целевой узел}
    \STATE {сконструировать путь}
    \RETURN {``успешное завершение''}
  \ENDIF
  \FOR {каждый наследик $n'$ из узла $n$}
    \STATE {$newg = n.g$ + \textsc{Стоимость}($n$, $n'$)}
    \IF {$n'$ в $Open$ или $Closed$, и $n'.g \leq newg$}
      \STATE {пропустить $n'$}
    \ENDIF
    \STATE {$n'$.родитель = $n$}
    \STATE {$n'.g = newg$}
    \STATE {$n'.h$ = \textsc{Эвристическая\_Оценка}($n'$)}
    \STATE {$n'.f = n'.g + n'.h$}
    \IF {$n'$ в $Closed$}
      \STATE {удалить $n'$ из $Closed$}
    \ENDIF
    \IF {$n'$ не в $Open$}
      \STATE {положить $n'$ в $Open$}
    \ENDIF
  \ENDFOR
  \STATE {положить $n$ в $Closed$}
\ENDWHILE
\RETURN {``путь не найден''}
\end{algorithmic}

\newpage

\myappendix{}
 Рассмотрим пример работы программы. В прямоугольном полом параллелепипеде (статическая фигура)
со сторонами\footnote{За $1$ будем считать еденицу виртуального пространства} $6\times6\times60$,
у которого отсутствуют передняя и задняя грань,
есть две одинаковых фигуры (кубы со стороными $3\times3\times3$),
одна из которых является динамической, а другая статической.
 Между фигурами наугад помещаются препятствия в виде частиц размером $1\times1\times1$,
а затем находится и моделируется решение транспортной задачи (рис. 1).
\begin{figure}[ht]
 \begin{center}
 \includegraphics[width=0.8\linewidth]{dynamic.png}
 \caption{Моделирование решения}
 \end{center}
 \label{dynamic}
\end{figure}
 Задача решается для различного количества препятствий и записывается
время, которое понадобилось для перемещения динамической фигуры. Результат
удобно наблюдать в виде графика (рис. 2).
\begin{figure}[ht]
 \begin{center}
 \includegraphics[width=0.5\linewidth]{dependence.jpg}
 \caption{Зависимость затраченного времени от количества преград}
 \end{center}
 \label{plot}
\end{figure}
\newpage


\tableofcontents

\end{document}
